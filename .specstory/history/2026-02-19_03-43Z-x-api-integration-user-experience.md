<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- cursor Session a1b62510-dc8f-47a5-92e9-c9760a1c4fa6 (2026-02-19 03:43Z) -->

# X API integration user experience (2026-02-19 03:43Z)

_**User**_

X API Integration Plan
Context
Stashy currently shows tweets from a Supabase DB with no X/Twitter API connection. The user wants to add live X bookmarks as a second data source (per-user OAuth), display tweet engagement stats, and open article link cards in an in-app full-screen reader panel rather than a new tab.

Architecture Overview
Data Flow: Two Modes
"My Stash" (existing): reads from Supabase tweets table — no change to existing behavior
"X Bookmarks" (new): user connects their X account → live fetch from GET /2/users/:id/bookmarks
Auth Model: Per-user OAuth 2.0 PKCE
Each visitor connects their own X account. Tokens stored in httpOnly cookies (no Supabase Auth needed — keeps it simple). No DB schema changes required.

Files to Create
1. src/lib/twitter.ts
Type definitions and X API v2 → internal Tweet transformer.


// Key types
export interface XPublicMetrics { like_count, retweet_count, reply_count, bookmark_count, impression_count }
export interface XTokens { access_token, refresh_token, user_id, expires_at }

// Transformer: X API v2 response → Tweet[]
export function mapXBookmarksToTweets(data, includes): Tweet[]
Maps includes.users + includes.media + includes.tweets (quoted) onto each tweet. Handles media_keys → MediaItem[], entities.urls → link_cards[], referenced_tweets → quoted_tweet.

2. src/app/api/auth/twitter/route.ts
Initiates OAuth 2.0 PKCE. Generates code_verifier/code_challenge, stores verifier in a short-lived cookie, redirects to:


https://twitter.com/i/oauth2/authorize
  ?response_type=code
  &client_id=TWITTER_CLIENT_ID
  &redirect_uri=TWITTER_CALLBACK_URL
  &scope=bookmark.read+tweet.read+users.read+offline.access
  &state=<random>
  &code_challenge=<sha256(verifier)>
  &code_challenge_method=S256
3. src/app/api/auth/twitter/callback/route.ts
Handles redirect. Exchanges code + code_verifier for tokens via POST https://api.twitter.com/2/oauth2/token. Fetches GET /2/users/me to get the user's ID. Sets httpOnly cookies: x_access_token, x_refresh_token, x_user_id, x_expires_at. Redirects to /?xConnected=1.

4. src/app/api/auth/twitter/disconnect/route.ts
Clears the X token cookies. Simple POST → clears cookies → redirect.

5. src/app/api/twitter/bookmarks/route.ts
Server-side proxy that:

Reads x_access_token + x_user_id from cookies
Calls GET /2/users/:id/bookmarks with:
tweet.fields=created_at,public_metrics,entities,in_reply_to_user_id,conversation_id,referenced_tweets,attachments
expansions=author_id,attachments.media_keys,referenced_tweets.id,referenced_tweets.id.author_id
user.fields=name,username,profile_image_url
media.fields=url,preview_image_url,type,width,height
max_results=20 + optional pagination_token query param
Calls mapXBookmarksToTweets() to transform response
Returns { tweets: Tweet[], next_token: string | null }
Token refresh logic: if 401, try refreshing with x_refresh_token before failing.

6. src/app/api/read-article/route.ts
Article content extractor:

Accepts GET /api/read-article?url=<url>
Fetches URL server-side (bypasses CORS)
Parses with @mozilla/readability + jsdom
Returns { title, byline, content, excerpt, siteName } or { error } on failure
7. src/components/ArticleReaderView.tsx
Full-screen overlay component. Shown when articleUrl is set in page state.

Layout:


┌─────────────────────────────────┐
│  ← Back to feed    [Open in ↗]  │  ← sticky header
│  ─────────────────────────────  │
│  Article Title                  │
│  By Author · site.com · date    │
│  ─────────────────────────────  │
│  [Original tweet card]          │  ← compact TweetCard
│  ─────────────────────────────  │
│  Full article body text...      │  ← rendered HTML from readability
│  (max-w-[680px] centered)       │
└─────────────────────────────────┘
Shows loading skeleton while fetching. Graceful fallback if extraction fails: "Couldn't extract article — [Open in browser ↗]".

8. src/components/XConnectBanner.tsx
Shown in the feed area when dataSource === "bookmarks" but user hasn't connected X. Shows the X logo, brief description, and "Connect X Account" button that calls /api/auth/twitter.

9. src/contexts/XAuthContext.tsx
Client-side context that checks GET /api/auth/twitter/status (reads cookies server-side, returns { connected: boolean, handle?: string }). Exposes { isConnected, xHandle, checkStatus }.

10. src/app/api/auth/twitter/status/route.ts
Returns { connected: true/false, handle: string | null } by checking if x_access_token cookie exists and is not expired.

Files to Modify
src/lib/supabase.ts
Add public_metrics as an optional field to the Tweet interface:


public_metrics?: {
  like_count: number;
  retweet_count: number;
  reply_count: number;
  bookmark_count: number;
  impression_count?: number;
};
src/components/TweetCard.tsx
Two changes:

Stats row — add after the existing content (tags/notes), only when tweet.public_metrics exists:


[reply icon] 67  [retweet icon] 45  [like icon] 123  [bookmark icon] 89  [views icon] 10K
Style matches Twitter's dim gray stat icons with hover highlight.

Article click handler — accept optional onArticleClick?: (url: string, tweet: Tweet) => void prop. When a link card is clicked, call this instead of opening new tab. Pass down to LinkCard.

src/components/LinkCard.tsx
Accept optional onClick?: (url: string) => void prop. When provided, call it on click instead of opening the URL in a new tab.

src/components/TweetFeed.tsx
Major changes:

Accept dataSource: "stash" | "bookmarks" prop
When dataSource === "bookmarks": fetch from /api/twitter/bookmarks?cursor=<token> using cursor pagination instead of page-offset; hide search/tag filters
Accept onArticleClick?: (url: string, tweet: Tweet) => void prop and pass down to TweetCard
Show XConnectBanner when bookmarks + not connected
src/app/page.tsx
Add articleUrl: string | null and articleTweet: Tweet | null state
Add dataSource: "stash" | "bookmarks" state (default: "stash")
When in view === "twitter": render data source toggle pills above TweetFeed
Pass onArticleClick to TweetFeed → sets articleUrl + articleTweet
Render <ArticleReaderView> as a full-screen overlay when articleUrl is set
Wrap with <XAuthProvider>
src/components/LeftSidebar.tsx
No structural changes. X connection status shown in the data source toggle on the main feed, not in the sidebar.

.env.example
Add:


TWITTER_CLIENT_ID=
TWITTER_CLIENT_SECRET=
TWITTER_CALLBACK_URL=http://localhost:3000/api/auth/twitter/callback
package.json
Add dependencies:

@mozilla/readability — article extraction
jsdom — HTML parsing for Readability
@types/jsdom (devDependency)
Data Source Toggle UI
In page.tsx, above the Twitter feed:


┌──────────────────────────────────────┐
│  [My Stash]  [X Bookmarks]           │  ← segmented control, X logo on right tab
│                                      │
│  [SearchBar — hidden in bookmarks]   │
└──────────────────────────────────────┘
Toggle is client-side state. Switching to X Bookmarks checks connection status and shows banner if not connected.

X API Mapping Details
X API v2 field	Tweet field
id	tweet_id
text	tweet_text
created_at	timestamp
includes.users[author_id].name	author_display_name
includes.users[author_id].username	author_handle
includes.users[author_id].profile_image_url	author_avatar_url
public_metrics	public_metrics (new field)
attachments.media_keys → includes.media	media[]
entities.urls (non-twitter urls)	link_cards[] (url+display_url only; no OG enrichment in live mode)
referenced_tweets[type=quoted] → includes.tweets	quoted_tweet
in_reply_to_user_id (non-null)	in_reply_to_tweet_id (use as proxy)
id (Twitter URL)	source_url = https://x.com/${handle}/status/${id}
For id in the returned Tweet objects from bookmarks: use a negative hash or prefix string since Supabase id is numeric and these won't be in DB. Use tweet_id as the React key.

Verification
Set TWITTER_CLIENT_ID, TWITTER_CLIENT_SECRET, TWITTER_CALLBACK_URL in .env.local
Start dev server: npm run dev
Navigate to Twitter tab → click "X Bookmarks" → see Connect banner → click "Connect X Account"
Complete OAuth flow → redirected back with xConnected=1
Bookmarks load in feed with media, stats, quote tweets
Click a tweet with a link card → article reader slides in
Article body extracted and rendered; back button returns to feed
Click "My Stash" → switches back to Supabase data (unchanged behavior)
Disconnect X → banner reappears

can you tell me what the user experience will be after this. how will it be different?

---

_**Agent (model gpt-5.3-codex, mode Agent)**_

<think><details><summary>Thought Process</summary>
**Summarizing user experience changes**</details></think>

---

After this integration, the product experience shifts from a **single static source** to a **dual-source, interactive reading workflow**.

## What Users Will Notice

- They can choose between **`My Stash`** (current Supabase feed) and **`X Bookmarks`** (live personal bookmarks from their own X account).
- The first time they choose **X Bookmarks**, they’ll see a clear **Connect X Account** prompt instead of an empty feed.
- Once connected, bookmarks load live with richer tweet metadata: **reply / repost / like / bookmark / view counts**.
- Link clicks no longer kick users out to a new tab by default; instead, links open in a **full-screen in-app reader** with:
  - back-to-feed control
  - original tweet context
  - extracted article body for focused reading
  - fallback “Open in browser” if extraction fails
- If they disconnect X, the bookmarks view gracefully reverts to the connect banner.

## What Stays the Same

- **`My Stash` behavior is unchanged** (same Supabase-backed feed).
- Existing sidebar structure remains unchanged.
- Users can still open the original article externally if they want.

## UX Difference in Plain Terms

Before: users only saw saved tweets from your DB and mostly left the app to read links.  
After: users get a **personalized live bookmarks mode + native reading experience**, so discovery and deep reading both happen inside Stashy, with less context switching and stronger “this app is my reading hub” feel.

---

_**User**_

rate the plan out of 10

---

_**Agent (model gpt-5.3-codex, mode Agent)**_

<think><details><summary>Thought Process</summary>
**Providing concise plan evaluation**</details></think>

---

**8.5/10**

Strong plan overall — it’s specific, implementable, and product-focused.  
Why it scores high:

- Clear separation of concerns (`My Stash` unchanged vs `X Bookmarks` live mode).
- Practical OAuth approach (PKCE + httpOnly cookies) with minimal scope creep.
- Good UX thinking (connect banner, data-source toggle, in-app reader fallback path).
- Solid API shaping and transform strategy (`mapXBookmarksToTweets` as boundary layer).
- Backward-compatible schema impact (`public_metrics` optional).

What keeps it from a 9.5+:

- Cookie/token lifecycle needs tighter security detail (cookie flags, CSRF `state` validation, refresh rotation behavior, revoke on disconnect).
- No explicit rate-limit/backoff strategy for X API failures.
- No caching/revalidation strategy for bookmarks and article extraction (could become slow/costly).
- “No DB changes” is fast, but limits auditability/debugging for OAuth sessions over time.
- Verification step mentions `npm run dev` (fine for humans), but engineering plan should also include non-interactive checks (typecheck/lint/test) as acceptance gates.

If you want, I can give you a **“make this a 10/10” hardening checklist** in priority order (security, reliability, performance, and UX edge cases).

---

_**User**_

i have a consumer key, secret key and bearer token, how does that correspond to my app's env?

---

_**Agent (model gpt-5.3-codex, mode Agent)**_

<think><details><summary>Thought Process</summary>
**Clarifying OAuth2 PKCE details**</details></think>

---

Short mapping:

- **Consumer Key** (aka API Key) -> `TWITTER_CLIENT_ID` *(in many older setups this is the closest equivalent)*
- **Secret Key** (aka API Key Secret / Consumer Secret) -> `TWITTER_CLIENT_SECRET`
- **Bearer Token** -> **not needed** for your per-user bookmarks OAuth flow

For your current plan, your `.env.local` should be:

```env
TWITTER_CLIENT_ID=...
TWITTER_CLIENT_SECRET=...
TWITTER_CALLBACK_URL=http://localhost:3000/api/auth/twitter/callback
```

Important nuance:

- The **Bearer token is app-only auth** (no user context), so it cannot represent “this logged-in user’s bookmarks”.
- Bookmarks require **user OAuth tokens** (`access_token` + `refresh_token`) obtained after the PKCE callback, then stored in cookies (as in your plan).

If your X portal shows both **Client ID/Client Secret** and **API Key/API Secret**, use **Client ID/Client Secret** first for OAuth 2.0. If it only shows Consumer/API Key names, map them as above.

---

_**User**_

how can we push to the existing vercel app ? its on my alt email account 

---

_**Agent (model gpt-5.3-codex, mode Agent)**_

<think><details><summary>Thought Process</summary>
**Explaining deployment options to alternate Vercel account**</details></think>

---

Best path: **don’t “push directly” to Vercel from local account creds**. Instead, connect your current Git repo/identity to that existing Vercel project cleanly.

## Option 1 (recommended): Git-based deploys via collaborator access

- Log into the alt Vercel account and open the project.
- Add your primary account as a **Project/Team member** (or transfer project to a Team both accounts can access).
- Ensure the project is connected to your GitHub repo/branch.
- Push code to the linked branch (`main` or whatever is configured) -> Vercel auto-deploys.

This is safest long-term and avoids token/account confusion.

## Option 2: Vercel CLI from your machine

If you want manual deploys from local:

1. Log out/in with the alt account in CLI:
   - `vercel logout`
   - `vercel login` (use alt email)
2. In repo root:
   - `vercel link` (select the existing project)
3. Deploy:
   - Preview: `vercel`
   - Production: `vercel --prod`

If you must stay logged into your primary account, use an alt-account token:
- Create token in alt account (`Account Settings -> Tokens`)
- Run with token: `vercel --token <ALT_TOKEN> --prod`

## If GitHub account access is the blocker

- Add your primary GitHub user as collaborator on the repo (or org/team access).
- Then in Vercel, ensure Git integration points to that repo and branch.

## Quick sanity checks when it “doesn’t deploy”

- Wrong Vercel scope/team selected in CLI.
- Project linked to a different repo/branch.
- Missing env vars in Vercel project (prod/preview scopes).
- You deployed preview but expected production.

If you want, I can give you the exact 5-command sequence for your setup (Git deploy vs CLI deploy) based on how your project is currently connected.

---

_**User**_

what shoudl i enter for Callback URI / Redirect URL(required)


---

_**Agent (model gpt-5.3-codex, mode Agent)**_

Use the exact URL of your OAuth callback route in this app:

- **Local dev:** `http://localhost:3000/api/auth/twitter/callback`
- **Production (Vercel):** `https://<your-domain>/api/auth/twitter/callback`

For example, if your Vercel domain is `stashy.vercel.app`, then:

- `https://stashy.vercel.app/api/auth/twitter/callback`

Also make sure `TWITTER_CALLBACK_URL` in your env **matches one of the registered callback URLs exactly** (protocol, domain, path, trailing slash). If they differ even slightly, X will reject the OAuth exchange.

---

_**User**_

i can confirm github repo is linked toverecl

---

_**Agent (model gpt-5.3-codex, mode Agent)**_

Perfect — then deploy flow is simple now:

- Push changes to the branch Vercel is watching (usually `main`).
- Vercel will auto-build and deploy.

Before pushing, make sure the Vercel project has the same required env vars:

- `TWITTER_CLIENT_ID`
- `TWITTER_CLIENT_SECRET`
- `TWITTER_CALLBACK_URL` (must be your production callback, e.g. `https://<domain>/api/auth/twitter/callback`)

Also register that same production callback URL in the X app settings.

Quick verify sequence after deploy:

- Open deployed app -> go to X Bookmarks -> Connect X Account
- Complete OAuth -> should return to `/?xConnected=1`
- If callback fails, 90% of the time it’s a callback URL mismatch or missing env var in Vercel.

---

_**User**_

what if i wanted to push to a preview branch and get a preview url

---

_**Agent (model gpt-5.3-codex, mode Agent)**_

That’s the best workflow for this kind of change.

## Branch preview flow

- Create/push a non-production branch (example: `feature/x-bookmarks`).
- If Vercel repo integration is active, each push to that branch gets an automatic **Preview Deployment URL**.
- Open Vercel dashboard -> project -> Deployments -> latest preview URL.

## Important for OAuth on preview

For X OAuth to work on preview, add that exact preview domain callback too:

- Callback format: `https://<preview-domain>/api/auth/twitter/callback`
- Set `TWITTER_CALLBACK_URL` in Vercel **Preview** env scope to that URL.

### Reality check
Preview URLs can change per deployment (`*.vercel.app`), which is annoying for OAuth providers that require exact callback URLs.

Best practice:
- Use a stable preview domain (e.g. `staging.yourdomain.com`) mapped to Vercel preview/staging.
- Register that stable domain once in X app.
- Set `TWITTER_CALLBACK_URL` (Preview env) to `https://staging.yourdomain.com/api/auth/twitter/callback`.

## Minimal command flow (local)

```bash
git checkout -b feature/x-bookmarks
git push -u origin feature/x-bookmarks
```

After that, Vercel auto-creates the preview deployment.

If you want, I can give you a concrete setup for **stable staging domain + preview env vars** so OAuth works every time without reconfiguring callbacks.

---

